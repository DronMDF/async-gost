
#include "CryptoEngineGeneric.h"

#include <cstring>
#include <utility>
#include <vector>
#include "CryptoRequest.h"
#include "upp11.h"

using namespace std;
using namespace std::placeholders;

CryptoEngineGeneric::CryptoEngineGeneric()
	: slot(bind(memcpy, &key[0], _1, sizeof(key)), &A, &B)
{
	const uint8_t FapsiSubst[] = {
		0xc4, 0xed, 0x83, 0xc9, 0x92, 0x98, 0xfe, 0x6b,
		0xff, 0xbe, 0x65, 0x5c, 0xe5, 0x2c, 0xb9, 0x20,
		0x89, 0x57, 0x16, 0xb3, 0x11, 0xf3, 0x98, 0x06,
		0x30, 0x79, 0xc0, 0x97, 0xa8, 0x1a, 0x5d, 0xd5,
		0x2e, 0x01, 0xda, 0x34, 0x73, 0xd5, 0x3b, 0xe8,
		0x4b, 0xc2, 0x77, 0x7e, 0xdc, 0x64, 0xac, 0xaf,
		0x6d, 0xa6, 0x02, 0xf1, 0x07, 0x4f, 0xe1, 0x4a,
		0xba, 0x30, 0x2f, 0x12, 0x56, 0x8b, 0x44, 0x8d
	};

	set_sbox(FapsiSubst);
}

void CryptoEngineGeneric::expand_tab(const uint8_t sbox[64], uint32_t tab[256], int shift) const
{
	for (int i = 0; i < 256; i++) {
		tab[i] = (sbox[(i / 16) * 4 + shift] & 0xf0) + (sbox[(i % 16) * 4 + shift] & 0x0f);
		tab[i] <<= shift * 8;
		tab[i] = (tab[i] << 11) | ((tab[i] >> 21) & 0x7ff);
	}
}

void CryptoEngineGeneric::set_sbox(const uint8_t sbox[64])
{
	expand_tab(sbox, tab1, 0);
	expand_tab(sbox, tab2, 1);
	expand_tab(sbox, tab3, 2);
	expand_tab(sbox, tab4, 3);
}

uint32_t CryptoEngineGeneric::step(uint32_t a, uint32_t b, uint32_t key) const
{
	const uint32_t tmp = key + b;
	return a ^ tab1[tmp & 0xff] ^ tab2[(tmp >> 8) & 0xff] ^ tab3[(tmp >> 16) & 0xff] ^
			tab4[(tmp >> 24) & 0xff];
}

void CryptoEngineGeneric::imit()
{
	for (int i = 0; i < 2; i++) {
		B = step(B, A, key[0]);
		A = step(A, B, key[1]);
		B = step(B, A, key[2]);
		A = step(A, B, key[3]);
		B = step(B, A, key[4]);
		A = step(A, B, key[5]);
		B = step(B, A, key[6]);
		A = step(A, B, key[7]);
	}
}

void CryptoEngineGeneric::encrypt()
{
	swap(A, B);

	for (int i = 0; i < 3; i++) {
		A = step(A, B, key[0]);
		B = step(B, A, key[1]);
		A = step(A, B, key[2]);
		B = step(B, A, key[3]);
		A = step(A, B, key[4]);
		B = step(B, A, key[5]);
		A = step(A, B, key[6]);
		B = step(B, A, key[7]);
	}

	A = step(A, B, key[7]);
	B = step(B, A, key[6]);
	A = step(A, B, key[5]);
	B = step(B, A, key[4]);
	A = step(A, B, key[3]);
	B = step(B, A, key[2]);
	A = step(A, B, key[1]);
	B = step(B, A, key[0]);
}

vector<CryptoEngineSlot> CryptoEngineGeneric::getSlots()
{
	return { CryptoEngineSlot(bind(memcpy, &key[0], _1, sizeof(key)), &A, &B) };
}

UP_SUITE_BEGIN(suiteCryptoEngineGeneric)

static const vector<uint8_t> key01 = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
static const vector<uint8_t> key02 = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
static const vector<uint8_t> key03 = {
	0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa,
	0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa,
	0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa,
	0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa };
static const vector<uint8_t> key04 = {
	0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
	0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
	0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
	0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55 };
static const vector<uint8_t> key05 = {
	0x04, 0x75, 0xF6, 0xE0, 0x50, 0x38, 0xFB, 0xFA,
	0xD2, 0xC7, 0xC3, 0x90, 0xED, 0xB3, 0xCA, 0x3D,
	0x15, 0x47, 0x12, 0x42, 0x91, 0xAE, 0x1E, 0x8A,
	0x2F, 0x79, 0xCD, 0x9E, 0xD2, 0xBC, 0xEF, 0xBD };

static const auto encrypt_params = {
	make_tuple(key01, 0xCCCCCCCCU, 0x33333333U, 0xF5FE5211U, 0x17E8D02EU),
	make_tuple(key01, 0x33333333U, 0xCCCCCCCCU, 0x6390ED97U, 0x3A962C89U),
	make_tuple(key02, 0xCCCCCCCCU, 0x33333333U, 0x2A78B7E0U, 0x800A0268U),
	make_tuple(key02, 0x33333333U, 0xCCCCCCCCU, 0x462DA336U, 0xEAB90129U),
	make_tuple(key03, 0xCCCCCCCCU, 0x33333333U, 0x8BB8CF97U, 0x533CDA6BU),
	make_tuple(key03, 0x33333333U, 0xCCCCCCCCU, 0xBE407AB5U, 0x5C055B4FU),
	make_tuple(key04, 0xCCCCCCCCU, 0x33333333U, 0x895A9742U, 0x02DB134CU),
	make_tuple(key04, 0x33333333U, 0xCCCCCCCCU, 0xDAA70325U, 0xB95DDC39U),
	make_tuple(key05, 0xCCCCCCCCU, 0x33333333U, 0x401EBED9U, 0x56F5D77DU),
	make_tuple(key05, 0x33333333U, 0xCCCCCCCCU, 0x4E790503U, 0x73FE0118U),
};

UP_PARAMETRIZED_TEST(encryptShouldBeCorrect, encrypt_params,
		     vector<uint8_t>, uint32_t, uint32_t, uint32_t, uint32_t)
{
	const auto key = get<0>(encrypt_params);
	const auto A = get<1>(encrypt_params);
	const auto B = get<2>(encrypt_params);
	const auto eA = get<3>(encrypt_params);
	const auto eB = get<4>(encrypt_params);

	shared_ptr<CryptoEngine> engine = make_shared<CryptoEngineGeneric>();
	const auto slots = engine->getSlots();
	for (auto slot: slots) {
		slot.setKey(&key[0]);
		slot.setBlock(A, B);
		engine->encrypt();
		uint32_t rA, rB;
		slot.getData(&rA, &rB);
		UP_ASSERT_EQUAL(rA, eA);
		UP_ASSERT_EQUAL(rB, eB);
	}
}

UP_SUITE_END()
