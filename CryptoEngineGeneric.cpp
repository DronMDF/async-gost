
#include "CryptoEngineGeneric.h"

#include <cstring>
#include <utility>
#include <vector>
#include <boost/test/unit_test.hpp>
#include "CryptoRequest.h"

using namespace std;
using namespace std::placeholders;

CryptoEngineGeneric::CryptoEngineGeneric()
	: slot(bind(memcpy, &key[0], _1, sizeof(key)), &A, &B)
{
	const uint8_t FapsiSubst[] = {
		0xc4, 0xed, 0x83, 0xc9, 0x92, 0x98, 0xfe, 0x6b,
		0xff, 0xbe, 0x65, 0x5c, 0xe5, 0x2c, 0xb9, 0x20,
		0x89, 0x57, 0x16, 0xb3, 0x11, 0xf3, 0x98, 0x06,
		0x30, 0x79, 0xc0, 0x97, 0xa8, 0x1a, 0x5d, 0xd5,
		0x2e, 0x01, 0xda, 0x34, 0x73, 0xd5, 0x3b, 0xe8,
		0x4b, 0xc2, 0x77, 0x7e, 0xdc, 0x64, 0xac, 0xaf,
		0x6d, 0xa6, 0x02, 0xf1, 0x07, 0x4f, 0xe1, 0x4a,
		0xba, 0x30, 0x2f, 0x12, 0x56, 0x8b, 0x44, 0x8d
	};

	set_sbox(FapsiSubst);
}

void CryptoEngineGeneric::expand_tab(const uint8_t sbox[64], uint32_t tab[256], int shift) const
{
	for (int i = 0; i < 256; i++) {
		tab[i] = (sbox[(i / 16) * 4 + shift] & 0xf0) + (sbox[(i % 16) * 4 + shift] & 0x0f);
		tab[i] <<= shift * 8;
		tab[i] = (tab[i] << 11) | ((tab[i] >> 21) & 0x7ff);
	}
}

void CryptoEngineGeneric::set_sbox(const uint8_t sbox[64])
{
	expand_tab(sbox, tab1, 0);
	expand_tab(sbox, tab2, 1);
	expand_tab(sbox, tab3, 2);
	expand_tab(sbox, tab4, 3);
}

uint32_t CryptoEngineGeneric::step(uint32_t a, uint32_t b, uint32_t key) const
{
	const uint32_t tmp = key + b;
	return a ^ tab1[tmp & 0xff] ^ tab2[(tmp >> 8) & 0xff] ^ tab3[(tmp >> 16) & 0xff] ^
			tab4[(tmp >> 24) & 0xff];
}

void CryptoEngineGeneric::imit()
{
	for (int i = 0; i < 2; i++) {
		B = step(B, A, key[0]);
		A = step(A, B, key[1]);
		B = step(B, A, key[2]);
		A = step(A, B, key[3]);
		B = step(B, A, key[4]);
		A = step(A, B, key[5]);
		B = step(B, A, key[6]);
		A = step(A, B, key[7]);
	}
}

void CryptoEngineGeneric::encrypt()
{
	swap(A, B);

	for (int i = 0; i < 3; i++) {
		A = step(A, B, key[0]);
		B = step(B, A, key[1]);
		A = step(A, B, key[2]);
		B = step(B, A, key[3]);
		A = step(A, B, key[4]);
		B = step(B, A, key[5]);
		A = step(A, B, key[6]);
		B = step(B, A, key[7]);
	}

	A = step(A, B, key[7]);
	B = step(B, A, key[6]);
	A = step(A, B, key[5]);
	B = step(B, A, key[4]);
	A = step(A, B, key[3]);
	B = step(B, A, key[2]);
	A = step(A, B, key[1]);
	B = step(B, A, key[0]);
}

unsigned CryptoEngineGeneric::getSlotCount() const
{
	return 1;
}

const CryptoEngineSlot *CryptoEngineGeneric::getSlot(unsigned s) const
{
	assert(s == 0);
	return &slot;
}

BOOST_AUTO_TEST_SUITE(suiteCryptoEngineGeneric)

void CUSTOM_REQUIRE_ENCRYPT(const vector<uint8_t> &key, uint32_t A, uint32_t B, uint32_t eA, uint32_t eB)
{
	CryptoEngineGeneric engine;
	engine.getSlot(0)->setKey(&key[0]);
	engine.getSlot(0)->setBlock(A, B);
	engine.encrypt();
	uint32_t rA, rB;
	engine.getSlot(0)->getData(&rA, &rB);
	BOOST_REQUIRE_EQUAL(rA, eA);
	BOOST_REQUIRE_EQUAL(rB, eB);
}

BOOST_AUTO_TEST_CASE(encryptShouldBeCorrect)
{
	const vector<uint8_t> key01 = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
	CUSTOM_REQUIRE_ENCRYPT(key01, 0xCCCCCCCC, 0x33333333, 0xF5FE5211, 0x17E8D02E);
	CUSTOM_REQUIRE_ENCRYPT(key01, 0x33333333, 0xCCCCCCCC, 0x6390ED97, 0x3A962C89);

	const vector<uint8_t> key02 = {
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
	CUSTOM_REQUIRE_ENCRYPT(key02, 0xCCCCCCCC, 0x33333333, 0x2A78B7E0, 0x800A0268);
	CUSTOM_REQUIRE_ENCRYPT(key02, 0x33333333, 0xCCCCCCCC, 0x462DA336, 0xEAB90129);

	const vector<uint8_t> key03 = {
		0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa,
		0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa,
		0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa,
		0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa };
	CUSTOM_REQUIRE_ENCRYPT(key03, 0xCCCCCCCC, 0x33333333, 0x8BB8CF97, 0x533CDA6B);
	CUSTOM_REQUIRE_ENCRYPT(key03, 0x33333333, 0xCCCCCCCC, 0xBE407AB5, 0x5C055B4F);

	const vector<uint8_t> key04 = {
		0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
		0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
		0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
		0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55 };
	CUSTOM_REQUIRE_ENCRYPT(key04, 0xCCCCCCCC, 0x33333333, 0x895A9742, 0x02DB134C);
	CUSTOM_REQUIRE_ENCRYPT(key04, 0x33333333, 0xCCCCCCCC, 0xDAA70325, 0xB95DDC39);

	const vector<uint8_t> key05 = {
		0x04, 0x75, 0xF6, 0xE0, 0x50, 0x38, 0xFB, 0xFA,
		0xD2, 0xC7, 0xC3, 0x90, 0xED, 0xB3, 0xCA, 0x3D,
		0x15, 0x47, 0x12, 0x42, 0x91, 0xAE, 0x1E, 0x8A,
		0x2F, 0x79, 0xCD, 0x9E, 0xD2, 0xBC, 0xEF, 0xBD };
	CUSTOM_REQUIRE_ENCRYPT(key05, 0xCCCCCCCC, 0x33333333, 0x401EBED9, 0x56F5D77D);
	CUSTOM_REQUIRE_ENCRYPT(key05, 0x33333333, 0xCCCCCCCC, 0x4E790503, 0x73FE0118);
}

BOOST_AUTO_TEST_SUITE_END()
